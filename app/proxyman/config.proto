syntax = "proto3";

package xray.app.proxyman;
option csharp_namespace = "Xray.App.Proxyman";
option go_package = "github.com/4nd3r5on/Xray-core/app/proxyman";
option java_package = "com.xray.app.proxyman";
option java_multiple_files = true;

import "common/net/address.proto";
import "common/net/port.proto";
import "transport/internet/config.proto";
import "common/serial/typed_message.proto";

message InboundConfig {}

message AllocationStrategy {
  enum Type {
    // Always allocate all connection handlers.
    Always = 0;

    // Randomly allocate specific range of handlers.
    Random = 1;

    // External. Not supported yet.
    External = 2;
  }

  Type type = 1;

  message AllocationStrategyConcurrency { uint32 value = 1; }

  // Number of handlers (ports) running in parallel.
  // Default value is 3 if unset.
  AllocationStrategyConcurrency concurrency = 2;

  message AllocationStrategyRefresh { uint32 value = 1; }

  // Number of minutes before a handler is regenerated.
  // Default value is 5 if unset.
  AllocationStrategyRefresh refresh = 3;
}

enum KnownProtocols {
  HTTP = 0;
  TLS = 1;
}

message SniffingConfig {
  // Whether or not to enable content sniffing on an inbound connection.
  bool enabled = 1;

  // Override target destination if sniff'ed protocol is in the given list.
  // Supported values are "http", "tls", "fakedns".
  repeated string destination_override = 2;
  repeated string domains_excluded = 3;

  // Whether should only try to sniff metadata without waiting for client input.
  // Can be used to support SMTP like protocol where server send the first
  // message.
  bool metadata_only = 4;

  bool route_only = 5;
}

message ReceiverConfig {
  // PortList specifies the ports which the Receiver should listen on.
  xray.common.net.PortList port_list = 1;
  // Listen specifies the IP address that the Receiver should listen on.
  xray.common.net.IPOrDomain listen = 2;
  AllocationStrategy allocation_strategy = 3;
  xray.transport.internet.StreamConfig stream_settings = 4;
  bool receive_original_destination = 5;
  reserved 6;
  // Override domains for the given protocol.
  // Deprecated. Use sniffing_settings.
  repeated KnownProtocols domain_override = 7 [ deprecated = true ];
  SniffingConfig sniffing_settings = 8;
}

message OutboundConfig {}

// InboundHandlerConfig is the configuration for inbound handler.
message InboundHandlerConfig {
  // Tag of the inbound handler. The tag must be unique among all inbound
  // handlers
  string tag = 1;
  // Settings for how this inbound proxy is handled.
  xray.common.serial.TypedMessage receiver_settings = 2;
  // Settings for inbound proxy. Must be one of the inbound proxies.
  xray.common.serial.TypedMessage proxy_settings = 3;
  // Manager for callbacks, used for statistics mostly.
  xray.common.serial.TypedMessage callback_manager = 4;
}

// OutboundHandlerConfig is the configuration for outbound handler.
message OutboundHandlerConfig {
  // Tag of this outbound handler.
  string tag = 1;
  // Settings for how to dial connection for this outbound handler.
  xray.common.serial.TypedMessage sender_settings = 2;
  // Settings for this outbound proxy. Must be one of the outbound proxies.
  xray.common.serial.TypedMessage proxy_settings = 3;
  // If not zero, this outbound will be expired in seconds. Not used for now.
  int64 expire = 4;
  // Comment of this outbound handler. Not used for now.
  string comment = 5;
}

message SenderConfig {
  // Send traffic through the given IP. Only IP is allowed.
  xray.common.net.IPOrDomain via = 1;
  xray.transport.internet.StreamConfig stream_settings = 2;
  xray.transport.internet.ProxyConfig proxy_settings = 3;
  MultiplexingConfig multiplex_settings = 4;
}

message MultiplexingConfig {
  // Whether or not Mux is enabled.
  bool enabled = 1;
  // Max number of concurrent connections that one Mux connection can handle.
  int32 concurrency = 2;
  // Transport XUDP in another Mux.
  int32 xudpConcurrency = 3;
  // "reject" (default), "allow" or "skip".
  string xudpProxyUDP443 = 4;
}
